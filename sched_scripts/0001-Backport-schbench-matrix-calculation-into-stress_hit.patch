From 01de42b2b6ea6da1ebfc17f5e895e2af9ae4c3e9 Mon Sep 17 00:00:00 2001
From: Chen Yu <yu.c.chen@intel.com>
Date: Sat, 17 Jan 2026 20:53:05 +0800
Subject: [PATCH] Backport schbench matrix calculation into stress_hitm test

Signed-off-by: Chen Yu <yu.c.chen@intel.com>
---
 sched_scripts/stress_hitm.c | 122 +++++++++++++++++++++++++-----------
 1 file changed, 84 insertions(+), 38 deletions(-)

diff --git a/sched_scripts/stress_hitm.c b/sched_scripts/stress_hitm.c
index 3d19c2e..c625439 100644
--- a/sched_scripts/stress_hitm.c
+++ b/sched_scripts/stress_hitm.c
@@ -7,6 +7,7 @@
 #include <errno.h>
 #include <stdint.h>
 #include <time.h>
+#include <math.h>
 #include <sys/time.h>
 
 // Cache line size (x86-64 typical: 64 bytes) - critical for cache contention
@@ -19,6 +20,9 @@ char *shared_worker_buffer_pool = NULL;
 // Mutex to protect pool initialization (only once)
 pthread_mutex_t shared_worker_buffer_pool_mutex = PTHREAD_MUTEX_INITIALIZER;
 
+static unsigned long cache_footprint_kb = 256;
+static unsigned long matrix_size = 0;
+
 // Global benchmark stats (atomic for thread-safe accumulation)
 unsigned long long total_bytes_written = 0;	// Total bytes written by all threads
 struct timeval benchmark_start;			// Benchmark start time (ms precision)
@@ -41,16 +45,14 @@ struct buffer_header {
 // Work instance (per-thread params from argv)
 struct work_instance {
 	int thread_id;					// Numeric thread ID (0,1,2...)
+	int is_shared;					// 0: private buf, 1: shared buf
 	pthread_t tid;					// Pthread handle
 	unsigned long long pool_size_bytes;		// Total shared pool size (LLC)
 	unsigned int test_duration_sec;		// Test duration in seconds
 	struct thread_data *worker_data;		// Thread-private stats
+	unsigned long *worker_buffer;
 };
 
-// Dummy stat functions (preserve original empty impl)
-static void record_wi_duration(struct work_instance *wi, uint64_t tsc) { (void)wi; (void)tsc; }
-static void record_cpu_work(struct work_instance *wi, int cpu, unsigned long bytes) { (void)wi; (void)cpu; (void)bytes; }
-
 // Initialize a single buffer (spinlock + header)
 void initialize_buffer(char *buffer) {
 	struct buffer_header *bh = (struct buffer_header *)buffer;
@@ -83,24 +85,30 @@ static int init(struct work_instance *wi) {
 	// Unique random seed per thread (maximize random buffer selection)
 	dp->seed = wi->thread_id * time(NULL);
 
-	// Enforce 4KB alignment for the shared pool
-	if (wi->pool_size_bytes % BUFFER_SIZE != 0) {
-		warnx("Thread %d: Shared pool size %llu bytes is not 4KB-aligned", wi->thread_id, wi->pool_size_bytes);
-		errx(-1, "Pool size must be multiple of %d bytes (4KB)", BUFFER_SIZE);
-	}
 
-	// Mutex guard: ONLY THE FIRST THREAD allocates the shared pool
-	pthread_mutex_lock(&shared_worker_buffer_pool_mutex);
-	if (shared_worker_buffer_pool == NULL) {
-		// Allocate aligned memory for the shared LLC pool
-		shared_worker_buffer_pool = aligned_alloc(BUFFER_SIZE, wi->pool_size_bytes);
-		if (shared_worker_buffer_pool == NULL)
-			err(-1, "aligned_alloc failed for shared buffer pool (size %llu)", wi->pool_size_bytes);
-		// Initialize all buffers in the shared pool
-		init_shared_buffer_pool(shared_worker_buffer_pool, wi->pool_size_bytes);
+	if (wi->is_shared) {
+		// Enforce 4KB alignment for the shared pool
+		if (wi->pool_size_bytes % BUFFER_SIZE != 0) {
+			warnx("Thread %d: Shared pool size %llu bytes is not 4KB-aligned", wi->thread_id, wi->pool_size_bytes);
+			errx(-1, "Pool size must be multiple of %d bytes (4KB)", BUFFER_SIZE);
+		}
+		// Mutex guard: ONLY THE FIRST THREAD allocates the shared pool
+		pthread_mutex_lock(&shared_worker_buffer_pool_mutex);
+		if (shared_worker_buffer_pool == NULL) {
+			// Allocate aligned memory for the shared LLC pool
+			shared_worker_buffer_pool = aligned_alloc(BUFFER_SIZE, wi->pool_size_bytes);
+			if (shared_worker_buffer_pool == NULL)
+				err(-1, "aligned_alloc failed for shared buffer pool (size %llu)", wi->pool_size_bytes);
+			// Initialize all buffers in the shared pool
+			init_shared_buffer_pool(shared_worker_buffer_pool, wi->pool_size_bytes);
+		}
+		pthread_mutex_unlock(&shared_worker_buffer_pool_mutex);
+	} else {
+		wi->worker_buffer = malloc(wi->pool_size_bytes);
+		if (wi->worker_buffer == NULL)
+			err(-1, "aligned_alloc failed for private buffer pool (size %llu)", wi->pool_size_bytes);
+		memset(wi->worker_buffer, 0, wi->pool_size_bytes);
 	}
-	pthread_mutex_unlock(&shared_worker_buffer_pool_mutex);
-
 	return 0;
 }
 
@@ -111,6 +119,7 @@ static int cleanup(struct work_instance *wi) {
 		return 0;
 
 	free(dp);
+	free(wi->worker_buffer);
 	wi->worker_data = NULL;
 	return 0;
 }
@@ -141,6 +150,30 @@ static void dirty_buffer_intensive(char *buffer)
 	}
 }
 
+/*
+ * multiply two matrices in a naive way to emulate some cache footprint
+ */
+static void do_some_math(unsigned long *buf)
+{
+	unsigned long i, j, k;
+	unsigned long *m1, *m2, *m3;
+
+	m1 = buf;
+	m2 = buf + matrix_size * matrix_size;
+	m3 = buf + 2 * matrix_size * matrix_size;
+
+	for (i = 0; i < matrix_size; i++) {
+		for (j = 0; j < matrix_size; j++) {
+			m3[i * matrix_size + j] = 0;
+
+			for (k = 0; k < matrix_size; k++)
+				m3[i * matrix_size + j] +=
+					m1[i * matrix_size + k] *
+					m2[k * matrix_size + j];
+		}
+	}
+}
+
 // Contend for a random buffer in the SHARED pool (core RFO logic)
 static char *contend_for_buffer(struct work_instance *wi) {
 	struct thread_data *dp = wi->worker_data;
@@ -190,6 +223,9 @@ static void release_buffer(char *buffer) {
 static unsigned long long run(struct work_instance *wi) {
 	unsigned long long bytes_written = 0;
 	time_t start_time = time(NULL);
+	int shared = wi->is_shared;
+	unsigned long wr = (matrix_size*matrix_size +
+			matrix_size*matrix_size*matrix_size)*sizeof(unsigned long);
 
 	while (1) {
 		char *buffer;
@@ -199,19 +235,21 @@ static unsigned long long run(struct work_instance *wi) {
 		if (difftime(current_time, start_time) >= wi->test_duration_sec)
 			break;
 
-		// Contend for a random buffer in the SHARED pool
-		buffer = contend_for_buffer(wi);
-
-		// Intensive write to ALL cache lines (trigger massive RFO)
-		dirty_buffer_intensive(buffer);
-		bytes_written += BUFFER_SIZE;
+		if (shared) {
+			// Contend for a random buffer in the SHARED pool
+			buffer = contend_for_buffer(wi);
+			// Intensive write to ALL cache lines (trigger massive RFO)
+			dirty_buffer_intensive(buffer);
+			bytes_written += BUFFER_SIZE;
+		} else {
+			do_some_math(wi->worker_buffer);
+			bytes_written += wr;
+		}
 
-		// Release buffer (allow other threads to contend)
-		release_buffer(buffer);
 
-		// Dummy stat calls (preserve original API)
-		record_wi_duration(wi, 0);
-		record_cpu_work(wi, 0, BUFFER_SIZE);
+		if (wi->is_shared)
+			// Release buffer (allow other threads to contend)
+			release_buffer(buffer);
 	}
 
 	return bytes_written;
@@ -273,7 +311,7 @@ static void show_usage(const char *prog_name) {
 	fprintf(stderr, "  SHARED_POOL_KB:        Size of SHARED buffer pool (KB, multiple of 4)\n");
 	fprintf(stderr, "  TEST_DURATION_SEC:     Test duration in seconds (integer > 0)\n");
 	fprintf(stderr, "Example:\n");
-	fprintf(stderr, "  %s 8 20480 10    # 8 threads, 20480 KB shared pool, 10 second test\n\n", prog_name);
+	fprintf(stderr, "  %s 8 20480 10 0   # 8 threads, 20480 KB buffer, 10 second test, private buffer\n\n", prog_name);
 	exit(EXIT_FAILURE);
 }
 
@@ -295,12 +333,12 @@ int main(int argc, char *argv[]) {
 	unsigned long long pool_size_bytes;
 	unsigned int test_duration_sec;
 	struct work_instance *workers = NULL;
-	int i;
+	int i, is_shared;
 	void *ret;
 
-	// Check argument count (3 required)
-	if (argc != 4) {
-		fprintf(stderr, "Error: Invalid arguments (expected 3, got %d)\n", argc - 1);
+	// Check argument count (4 required)
+	if (argc != 5) {
+		fprintf(stderr, "Error: Invalid arguments (expected 4, got %d)\n", argc - 1);
 		show_usage(argv[0]);
 	}
 
@@ -330,6 +368,12 @@ int main(int argc, char *argv[]) {
 	}
 	test_duration_sec = atoi(argv[3]);
 
+	// Parse and validate shared or private indicator
+	//0: private, 1: share
+	is_shared = atoi(argv[4]);
+	if (!is_shared)
+		matrix_size = sqrt(pool_size_bytes / 3 / sizeof(unsigned long));
+
 	// Allocate work instances
 	workers = calloc(num_threads, sizeof(struct work_instance));
 	if (workers == NULL)
@@ -340,13 +384,15 @@ int main(int argc, char *argv[]) {
 		workers[i].thread_id = i;
 		workers[i].pool_size_bytes = pool_size_bytes;
 		workers[i].test_duration_sec = test_duration_sec;
+		workers[i].is_shared = is_shared;
 	}
 
 	// Start benchmark timer
 	gettimeofday(&benchmark_start, NULL);
 	printf("Starting RFO Cache Contention Benchmark...\n");
-	printf("Parameters: %d threads | %llu KB shared pool | %u second duration\n",
-		   num_threads, pool_size_kb, test_duration_sec);
+	printf("Parameters: %d threads | %llu KB %s pool | %u second duration\n",
+		   num_threads, pool_size_kb, is_shared ? "shared" : "private",
+		   test_duration_sec);
 
 	// Create threads (NO CPU AFFINITY - OS free scheduling)
 	for (i = 0; i < num_threads; i++) {
-- 
2.51.0

